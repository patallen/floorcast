from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING, Any, Callable, Coroutine, Protocol

from floorcast.domain.websocket import WSConnection, WSMessage

if TYPE_CHECKING:
    from floorcast.domain.models import CompactEvent, ConstructedState, Event, Registry, Snapshot


class SnapshotStore(Protocol):
    async def create(self, snapshot: Snapshot) -> Snapshot: ...
    async def get_latest(self) -> Snapshot | None: ...
    async def get_before_timestamp(self, timestamp: datetime) -> Snapshot | None: ...
    async def get_by_id(self, snapshot_id: int) -> Snapshot | None: ...


class EventStore(Protocol):
    async def create(self, event: Event) -> Event: ...
    async def get_by_id(self, event_id: int) -> Event | None: ...
    async def get_between_id_and_timestamp(
        self, event_id: int, timestamp: datetime
    ) -> list[Event]: ...
    async def get_timeline_between(
        self, start_id: int, end_time: datetime
    ) -> list[CompactEvent]: ...


class EventPublisher[T](Protocol):
    def subscribe[E](
        self, event_type: type[E], callback: Callable[[E], Coroutine[Any, Any, None]]
    ) -> Callable[[], None]: ...
    def publish(self, event: T) -> None: ...
    async def wait_all(self) -> None: ...


class StateReconstructor(Protocol):
    async def get_state_at(self, end_time: datetime) -> ConstructedState: ...


class SnapshotPolicy(Protocol):
    def should_snapshot(self, events_since_snapshot: int, last_snapshot_time: datetime) -> bool: ...


class RegistryStore(Protocol):
    def get_registry(self) -> Registry: ...


class WebsocketManager(Protocol):
    def send_message(self, conn: WSConnection, message: WSMessage) -> None: ...
    def connect(self) -> WSConnection: ...
    def disconnect(self, conn: WSConnection) -> None: ...
    async def request_registry(self, conn: WSConnection) -> None: ...
    async def request_snapshot(self, conn: WSConnection) -> None: ...
